#include <iostream>
#include <string>
#include <cstring>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <map>
#include <QProcess>

using namespace std;

struct DGNode//struct for dot_graph to store Node, with an unique index and name.
{
    //WARNING: Index can't be larger than 10010!
    DGNode()
    {
        name = "";
    }
    unsigned int index;
    string name;
};

struct DGEdge
{
    DGEdge(DGNode* a, DGNode* b, int w)
    {
        from = a; to = b; weight = w;
    }
    bool operator < (const DGEdge& toc) const
    {
        unsigned long long ths = from -> index * 65536 + to -> index;
        unsigned long long tht = toc.from -> index * 65536 + toc.to -> index;
        return ths < tht;
    }
    DGNode* from; DGNode* to; int weight;
};

class dot_graph//Class for getting a .gv file to use in the graphviz.
{
private:
    bool WriteOK, __init;
    string int2string(unsigned int idx)//Returns a unique string generated by the index for naming.
    {
        ++idx;//to prevent idx=0 problem.
        char aa[9];//tmp to store string.
        int now = -1;
        while(idx != 0)//"reverse-hash-like" way to build the string, all upper-case letters.
        {
            aa[++now] = 'A' + idx % 26;
            idx /= 26;
        }
        aa[++now] = '\0';
        string ret(aa);
        return ret;
    }
    string convert2string(int num)//Convert a number into string, modifying nothing. like: 3 to "3", etc.
    {
        char aa[66];
        sprintf(aa, "%d", num);
        string ret(aa);
        return ret;
    }
    string getstring(DGNode n)//Returns the name of the node, changint the special char into its escapes.
    {
        string esc;
        unsigned int num = n.name.length();
        for(unsigned int i = 0; i < num; ++i)
        {
            if(n.name[i] == '"' || n.name[i] == '\\')
            {
                esc += '\\';
                esc += n.name[i];
            }
            else
            {
                esc += n.name[i];
            }
        }
        //std::cout << esc << std::endl;
        return esc;
    }
    bool have_outputed(DGNode ex)
    {
        return outed[ex.index];
    }
    void set_outputed(DGNode ex)
    {
        outed[ex.index] = true;
    }
    bool outed[10010], highlighted[10010];//That's why!
    string dot_phrase;//Stores the text for .gv file.
public:
    dot_graph()
    {
        __init = 0;
        init();
        WriteOK = false;
    }
    void init()
    {
        if(__init) return;
        dot_phrase = "digraph G {\nsize = \"9, 10\";\n";//The fixed ones of the .gv file.
        memset(outed, false, sizeof(outed));
        memset(highlighted, false, sizeof(highlighted));
        __init = 1;
    }
    void sethighlight(DGNode ex)
    {
        highlighted[ex.index] = true;
    }
    void addedge(DGNode from, DGNode to, int weight, bool highlight)
    {
        //Use it to create an edge between two DGNodes.
        if(highlight)
        {
            dot_phrase += "edge[color = red];\n";
        }
        string fromidxstr = int2string(from.index);
        string toidxstr = int2string(to.index);
        dot_phrase += fromidxstr + " -> " + toidxstr + " [label = \"" + convert2string(weight) + "\"];\n";
        if(!have_outputed(from))
        {
            dot_phrase += int2string(from.index) + "[label = \"" + getstring(from) + "\"";
            if(highlighted[from.index])
            {
                dot_phrase += ", color = lightblue, style = filled";
            }
            dot_phrase += "];\n";
            set_outputed(from);
        }
        if(!have_outputed(to))
        {
            dot_phrase += int2string(to.index) + "[label = \"" + getstring(to) + "\"";
            if(highlighted[to.index])
            {
                dot_phrase += ", color = lightblue, style = filled";
            }
            dot_phrase += "];\n";
            set_outputed(to);
        }
        if(highlight)
        {
            dot_phrase += "edge[color = black];\n";
        }
    }
    bool getdv(const char* path)//Creates the .gv file.
    {
        //std::cout << dot_phrase << std::endl;
        WriteOK = 0;
        FILE* ofile = fopen(path, "w+");
        if(ofile == NULL) return false;
        int num = dot_phrase.length();
        for(int i = 0; i < num; ++i)
        {
            fprintf(ofile, "%c", dot_phrase[i]);
        }
        fprintf(ofile, "}\n");
        fclose(ofile);
        WriteOK = 1;
        return true;
    }
    void generateJPG(const char* dvpath)
    {
        while(!WriteOK)
        {
            continue;
        }
        //QString dd(dvpath);
        //dd = "cmd /c " + dd + ".bat";
        QString dd(dvpath);
        QProcess Process(0);
        Process.execute("dot", QStringList() << dd << "-Tjpg" << "-O");
    }
};
